## Gopherplate
gopherplate is a golang sql boilerplate generator tool that uses struct tags to convenient structs and sql statements. The idea behind gopherplate is to facilitate the task of writing raw `sql` by providing strings you can concatenate to form "complex" queries.

## INSTALL
```
go get github.com/martskins/gopherplate
```

## USAGE
`gopherplate` is a cli tool which receives the following arguments:

| long | short | description | default |
| ----|:----|:----|:----|
|pkg|p|name of the package to use in the generated files|main|
|output|o|name of the output file|gopherplate.go|
|engine|e|sql driver that you are using (postgres or mysql) |mysql|
|source|s|relative path to the folder in which the structs are defined ||
|table-name|t|overrides the table name for a struct: usage `-t StructName:table_name`||
|named||use named placeholders (true if passed) |false|
|export||export all generated statements |false|

This will scan the structs in the source folder and look for `gpl` struct tags in them. If a struct
has any, it will generated the corresponding sql statements.

Some tag modifiers exist, such as a:
- `select` if a field is tagged with this modifier, it will only be inlcuded in the select statment
- `update` if a field is tagged with this modifier, it will only be inlcuded in the update statment
- `join` if a field is tagged with this modifier, it will only be inlcuded in the join statment

If none of the above are included, the field will be included in all of the statements.

For example:

```go
// main.go
package main

//go:generate gopherplate --source . -t User:users --named

type User struct {
	ID 	int 		`db:"id" gpl:"id,select"` // the select modifier used here is to ommit the id in
							// insert and update statements
	Name 	string 		`db:"name" gpl:"name"`
	Email 	string 		`db:"email" gpl:"email"`
}

type Client struct {
	UserID 	int 	`db:"user_id" gpl:"user_id"`
	*User 	`db:"users" gpl:"users,select"` 	// the name of the prefix (users), on the field you want
							// to use for the related model, must match the name
							// of the database table you're joining
}

```

will result, after running `go generate ./...` in the following file being created:

```go
// gopherplate.go
/*
* This file was auto-generated by gopherplate (https://github.com/martskins/gopherplate).
* It is advisable to keep this file unchanged.
*/

package main

const insertUser = `INSERT INTO users (name, email) VALUES (:name, :email)`

const updateUser = `UPDATE users SET name = :name, email = :email WHERE `

const joinUser = `users.id as "users.id", users.name as "users.name" users.email as "users.email"`

// NullUser is a nullable User, mostly useful for left joins
type NullUser struct {
	ID *int `db:"id"`
	Name *string `db:"name"`
	Email *string `db:"email"`
}

// Valid indicates whether there is a User in this NullUser
func (n *NullUser) Valid() bool {
	if n.ID != nil || n.Name != nil || n.Email != nil {
		return true
	}
	return false
}

// Get returns the User in this NullUser
func (n *User) Get() *User {
	if !n.Valid() {
		return nil
	}

	return &User{
		ID: *n.ID,
		Name: *n.Name,
		Email: *n.Email,
	}
}

// MarshalJSON marshals a NullUser to json
func (n *NullUser) MarshalJSON() ([]byte, error) {
	if !n.Valid() {
		return []byte("null"), nil
	}

	return json.Marshal(n.Get())
}

```

the output includes statements for select, update and join and also a Nullable version of the
struct, to be used for example in inner joins.
